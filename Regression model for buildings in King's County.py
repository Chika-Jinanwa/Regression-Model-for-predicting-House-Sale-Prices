#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sat Feb 22 23:02:24 2020

@author: jinanwachikafavour
"""

import pandas as pd
from scipy import stats
import numpy as np
import matplotlib.pyplot as plt
url_data = 'https://docs.google.com/spreadsheets/d/1SlFAdx0R5fhQVV1rAoU6xcRIwbuV4-Qe87Mauluqgp0/export?format=csv'
#download csv file to python
housing_data = pd.read_csv(url_data) #feed into a Pandas module for analysis
print(housing_data)
price = list(housing_data['price'].values) #extract all the prices in the price column
print(price)
living_space = list (housing_data['sqft_living'].values) #extract areas of living spaces from sqft_living
print(living_space)
def mean(array):
    """Function that returns the mean of list/array object"""
    length = len(array) #total number of elements in list
    total=0 #initializes the sum of elements in list
    for elem in array: #iterates through each element
        total += elem #add element to total
    mean=total/length #compute the average
    if mean == np.mean(array):  #compare with mean generated by numpy module
        return mean
def standard_deviation(array):
    """Function that returns the standard deviation of a list/array object"""
    total = 0 #initializes sum of elements in the list
    total_square_deviation = 0 #initializes the sum of the squares of the deviations
    deviation_list = [] #initializes list which will contain squares of the deviations
    n = len(array) #number of elements in list
    for elem in array: #loops through each elem in array
        total += elem #adds the elem to total
    average = total/len(array) #computes mean
    for num in array: #loops through each element in array
        deviation_square = (num-average)**2 #square difference between number and mean
        deviation_list += [deviation_square] #add the square of deviations of each element to the list
    for num in deviation_list: #loops through each element in list
        total_square_deviation += num #sums the square of the deviations
    variance = total_square_deviation/(n-1) #computes variance with Bessel's correction for sample data
    std_dev = variance **0.5 #square root of variance
    
    return std_dev

def covariance(x,y):
    """Function that returns the cov(x,y). The formula of cov this function uses is derived in the hand
    calculation attached in the appendix B
    """
    summation = 0 #initialize sum
    n = len(x) #get sample size n
    b = mean(x)*mean(y) 
    for i, j in zip (x,y): #iterate through paired elements x and y
        inner_terms = (i*j) - b 
        #evaluates the inner terms of the formula
        summation+= inner_terms #increments the sum
    covariance = (1/(n-1))*summation
    return covariance

def correlation_r(x,y):
    """Function returns the correlation between two variables. The formula this function uses is also
    derived in the hand calculation attached in appendix B"""
    r=covariance(x,y)/(standard_deviation(x)*standard_deviation(y))
    return r


print( 'The correlation coefficient r is', correlation_r(living_space,price))
def regression_eqn(x,y):
    """Function returns the eqn of the least square regression line. The formula this function uses is
    derived in the hand calculation attached in Appendix C"""
    variance_x = (standard_deviation(x))**2 #compute variance
    global slope
    slope = covariance(x,y)/variance_x #compute slope
    global intercept
    intercept = mean(y) - slope*mean(x) #compute intercept
    a= 'Regression line equation is', 'y'+'='+ str(slope)+'x' + str(intercept)
    return a
regression_eqn(living_space,price)
list_y = [] #empty list that will contain the points on the line y^ that will be used to plot the regression line
list_x = [] #empty list that will contain x values that will be used to plot the regression line
for i in range(0,15000):
    list_x += [i] #add elem to list_x
for n in list_x:
    y =  (slope * n) + intercept #predict y using the regression eqn
    list_y += [y] 
def predict_value(x):
    """Function that predicts y given x using the regression eqn"""
    y = (slope * x) + intercept
    return y

residual_list = [] #list of residuals used for heteroscedastic plot below
for r,s in zip(living_space, price): #iterate through the paired values
    residual = s-predict_value(r)  #computes the residuals-y-y^
    residual_list += [residual] #append to residual list
print(residual_list)
plt.scatter(living_space,price, c='blue')#scatterplot of the variables of interest
plt.plot(list_x,list_y, c='black') #plot regression line
plt.xlabel('Area of living Space (Sq.ft)')
plt.ylabel('House Sale Price ($)')
plt.text(0,7000000,'r = 0.702')
plt.show()
plt.scatter(living_space,price, c='blue') #scatterplot of the variables of interest
plt.xlabel('Area of living Space (Sq.ft)')
plt.ylabel('House Sale Price ($)')
plt.text(0,7000000,'r = 0.702')
plt.show()
Rsquared = (correlation_r(living_space,price))**2 #compute R squared
print(Rsquared)
def standard_error(x,y):
    """Function returns the standard error using the formula stated in the main paper"""
    global std_err
    std_err = (((1-Rsquared)/(len(x)-2))**0.5)* (standard_deviation(y)/standard_deviation(x))
    return 'The standard error is', std_err
standard_error(living_space,price)
stats.t.ppf(0.95,21611)
def confidence_interval_95(x,y):
    """Function returns the confidence interval for population parameter"""
    global df
    df= len(x)-2 #degress of freedom
    t_score = stats.t.ppf(0.95,df)
    lower_bound = slope - (t_score*1.94) #compute lowerbound
    upper_bound = slope + (t_score*1.94) #compute upperbound
    return [lower_bound,upper_bound]
confidence_interval_95(living_space,price)
def t_score_significance(x,y):
    """Function returns the t-score for the hypothesis testing"""
    global t_score
    t_score = slope/std_err #compute t_score
    return t_score
    
print(t_score_significance(living_space,price)) 
def p_value():
    """Function returns the p-value, if output =='nan', the value is too small to be expressed as a float
    that is, approximately == 0"""
    percentile = stats.norm.ppf(t_score,df)
    return 1-percentile
p_value()
plt.hist(residual_list, bins= 30, edgecolor='black') #plot histogram of residuals 
plt.xlabel('Residuals (USD)')
plt.ylabel('Relative frequency')
plt.show()
plt.scatter(living_space,residual_list) #plots scatterplot of sg.ft vs residuals to test for homoscedasticity
plt.axhline(linewidth=1,color='k',linestyle='dashed') #plot a horizontal line (regression line) at 0 
plt.xlabel('Area of living spaces (Sq. ft)')
plt.ylabel('Residuals ($)')
plt.show()

# same model but built with the stats.model package
import pandas 
pandas.set_option('max_rows', 10)
import numpy as np
from scipy import stats
import matplotlib.pyplot as plt
import statsmodels.api as statsmodels # useful stats package with regression functions
import seaborn as sns # very nice plotting package

def regression_model(column_x, column_y):
    # this function uses built in library functions to create a scatter plot,
    # plots of the residuals, compute R-squared, and display the regression eqn

    # fit the regression line using "statsmodels" library:
    X = statsmodels.add_constant(housing_data[column_x])
    Y = housing_data[column_y]
    regressionmodel = statsmodels.OLS(Y,X).fit() #OLS = "ordinary least squares"
    
    # extract regression parameters from model, rounded to 3 decimal places:
    Rsquared = round(regressionmodel.rsquared,3)
    slope = round(regressionmodel.params[1],3)
    intercept = round(regressionmodel.params[0],3)
    
    # make plots:
    fig, (ax1, ax2) = plt.subplots(ncols=2, sharex=True, figsize=(12,4))
    sns.regplot(x=column_x, y=column_y, data=housing_data, marker="+", ax=ax1) # scatter plot
    sns.residplot(x=column_x, y=column_y, data=housing_data, ax=ax2) # residual plot
    ax2.set(ylabel='Residuals')
    ax2.set_ylim(min(regressionmodel.resid)-1,max(regressionmodel.resid)+1)
    plt.figure() # histogram
    sns.distplot(regressionmodel.resid, kde=False, axlabel='Residuals', color='red')
    
    # print the results:
    print("R-squared = ",Rsquared)
    print("Regression equation: "+column_y+" = ",slope,"* "+column_x+" + ",intercept)
regression_model('sqft_living','price')

